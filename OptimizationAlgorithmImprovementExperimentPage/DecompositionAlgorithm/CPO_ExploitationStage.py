import random
import math
import numpy as np

def exploitation_phase(Npop, Max_it, lb, ub, nD, fobj, Positions, fitness, Gb_Sol, Gb_Fit):
    t = 0
    Conv_curve = np.zeros(Max_it)
    Xp = Positions.copy()
    while t <= Max_it:
        r2 = random.random()
        for i in range(Npop):
            Yt = 2 * random.random() * (1 - t / Max_it) ** (t / Max_it)
            U2 = np.random.rand(nD) < 0.5 * 2 - 1
            S = random.random() * U2
            if random.random() < 0.8:  # Third defense mechanism
                St = math.exp(fitness[i] / (sum(fitness) + np.finfo(float).eps))
                S = S * Yt * St
                Positions[i, :] = (1 - U2) * Positions[i, :] + U2 * (Positions[random.randint(0, Npop - 1), :] + St * (Positions[random.randint(0, Npop - 1), :] - Positions[random.randint(0, Npop - 1), :]) - S)
            else:  # Fourth defense mechanism
                Mt = math.exp(fitness[i] / (sum(fitness) + np.finfo(float).eps))
                vt = Positions[i, :]
                Vtp = Positions[random.randint(0, Npop - 1), :]
                Ft = np.random.rand(nD) * (Mt * (-vt + Vtp))
                S = S * Yt * Ft
                Positions[i, :] = (Gb_Sol + (0.2 * (1 - r2) + r2) * (U2 * Gb_Sol - Positions[i, :])) - S

            # Boundary handling
            for j in range(nD):
                if Positions[i, j] > ub[j]:
                    Positions[i, j] = lb[j] + random.random() * (ub[j] - lb[j])
                elif Positions[i, j] < lb[j]:
                    Positions[i, j] = lb[j] + random.random() * (ub[j] - lb[j])

            # Fitness calculation and update
            nF = fobj(Positions[i, :])
            if fitness[i] < nF:
                Positions[i, :] = Xp[i, :]
            else:
                Xp[i, :] = Positions[i, :]
                fitness[i] = nF
                if fitness[i] <= Gb_Fit:
                    Gb_Sol = Positions[i, :]
                    Gb_Fit = fitness[i]

        t += 1
        if t > Max_it:
            break
        Conv_curve[t - 1] = Gb_Fit

        # Update population size
        Npop = int(120 + (Npop - 120) * (1 - (t % (Max_it / 2)) / (Max_it / 2)))

    return Gb_Fit, Gb_Sol, Conv_curve